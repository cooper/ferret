#!/usr/bin/perl
# Copyright (c) 2014 Mitchell Cooper

use warnings;
use strict;
use 5.010;

use File::Slurp  'slurp';
use Scalar::Util 'blessed';
use Getopt::Long::Descriptive;
use JSON::XS;

BEGIN {
    use FindBin;
    use lib 'lib';
    our $bin = $FindBin::Bin;
    use lib "$FindBin::Bin/lib";
}

use Ferret::Lexer;
use Ferret::Perl;

sub inter  (@);
sub interf (@);

my ($o, $usage) = describe_options(
    "$0 %o [file ...]",
    [ 'tokens|t'        => 'show tokenization'                          ],
    [ 'dom|d'           => 'show lexer object tree (DOM)'               ],
    [ 'show-all'        => 'include unknown objects in DOM'             ],
    [ 'stdout|s'        => 'write to STDOUT instead of file'            ],
    [ 'comments|c'      => 'write tokens/DOM as comments (with -t/-d)'  ],
    [ 'perltidy|p'      => 'beautify code with perltidy'                ],
    [ 'minify|m'        => 'minify code'                                ],
    [ 'help|h'          => 'show help'                                  ]
);

# show help.
print($usage->text) and exit if $o->help;

# handle each file.
do_file($_) foreach grep { substr($_, -3) eq 'frt' } @ARGV;

my $fh;
sub do_file {
    my $file = shift;
    say $file;

    # open the output file.
    if ($o->stdout) { $fh = \*STDOUT }
    else            { open $fh, '>', "$file.pm" }

    # parse the input file.
    my $str = eval { slurp($file) } or die "$!\n";

    # tokenize.
    my @tok = Ferret::Lexer::Tokenizer::tokenize($str);
    die "Error: ${$tok[0]}\n"
        if blessed $tok[0] && $tok[0]->isa('F::Error');
    if ($o->tokens) {
        inter "--- Tokens ---\n";
        show_tok(@tok);
    }

    # construct elements.
    my $doc = F::Document->new(name => $file);
    my $err = Ferret::Lexer::Constructor::construct($doc, @tok);
    if ($o->dom) {
        inter "--- DOM ---\n";
        show_dom($doc);
    }
    die "Error: $$err\n" if $err;

    # compile to Perl.
    my $compiled = Ferret::Perl::main($doc);
    beautify(\$compiled) if $o->perltidy;
    minify(\$compiled)   if $o->minify;

    # write to file.
    print $fh $compiled;
    close $fh;

}

sub show_tok {
    state $json = JSON::XS->new->allow_nonref(1);
    foreach (@_) {
        my ($label, $value) = @$_;
        interf "%15s | %s\n",
            $label,
            defined $value ? $json->encode($value) : '';
    }
}

sub show_dom {
    state $indent = 0;
    my $el = shift;
    return if $el->type eq 'Unknown' && !$o->unknown;
    interf "%s %s\n", '    ' x $indent, ucfirst $el->desc;
    return unless $el->is_node;
    $indent++;
        show_dom($_) foreach $el->children;
    $indent--;
}

sub inter (@) {
    my $str = join '', @_;
    print $fh "# $str";
    print $str;
}

sub interf (@) {
    my $str = shift;
    $str = sprintf $str, @_;
    print $fh "# $str";
    print $str;
}

sub perltidy {
    my ($ref, %opts) = @_;
    require Perl::Tidy;
    Perl::Tidy::perltidy(
        source      => $ref,
        destination => $ref,
        argv        => '',
        %opts
    );
}

sub beautify {
    my $ref = shift;
    perltidy($ref);
}

sub minify {
    my $ref = shift;
    perltidy($ref, argv => '--mangle -dac');
    $$ref =~ s/\n//g;
}
