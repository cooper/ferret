#!/usr/bin/perl
# Copyright (c) 2015, Mitchell Cooper

use warnings;
use strict;
use 5.010;

use utf8;
use open ':std', ':encoding(UTF-8)';

use File::Slurp     'slurp';
use Scalar::Util    'blessed';
use File::Basename  'fileparse';
use IO::Async::Function;
use IO::Async::Loop;
use Getopt::Long::Descriptive;
use JSON::XS;

BEGIN {
    use FindBin;
    use lib 'lib';
    our $bin = $FindBin::Bin;
    use lib "$FindBin::Bin/lib";
    do '/etc/ferret.conf' or die "config error: ".($@ || $!)
}

use Ferret::Lexer;
use Ferret::Perl;

my ($o, $usage) = describe_options(
    "$0 %o [file ...]",
    [ 'noskip|n'        => 'do not skip unchanged files'                ],
    [ 'synchronous|y'   => 'work one file at a time in a single thread '],
    [ 'clean|c'  => 'clean up build directories', {implies => 'noskip'} ],
    [ 'tokens|t'        => 'write tokenization'                         ],
    [ 'dom|d'           => 'write lexer object tree (DOM)'              ],
    [ 'show-all'        => 'include unknown objects in DOM'             ],
    [ 'verbose|v'       => 'print tokens/DOM to STDOUT (with -d/t)'     ],
    #[ 'stdout|s'        => 'write to STDOUT instead of file'            ],
    [ 'beautify|p'      => 'beautify code with perltidy'                ],
    [ 'minify|m'        => 'minify code'                                ],
    [ 'gendocs|D'       => 'generate documentation'                     ],
    [ 'help|h'          => 'show help'                                  ]
);

# show help.
print($usage->text) and exit if $o->help;

my (
    $loop,      # IO::Async::Loop
    $function,  # IO::Async compile function
    $pending,   # number of files in progress
    @errors     # postponed errors
);

# find the files.
my @files = grep { substr($_, -4) eq '.frt' } @ARGV;
   @files = split /\n/, `find . | grep '\\.frt\$'` if !@files;
   # TODO: do this right, support Windows, etc.

# do it synchronously.
if ($o->synchronous) {
    $pending = scalar @files;
    handle_result($_, 'return', do_file($_)) foreach @files;
}

# or asynchronously.
else {
    $loop = IO::Async::Loop->new;
    $function = IO::Async::Function->new(code => \&do_file);
    $loop->add($function);
    async_do_file($_) foreach @files;
    $loop->run;
}

sub async_do_file {
    my $file = shift;
    $pending++;
    $function->call(
        args => [ $file ],
        on_result => sub { handle_result($file, @_) }
    );
}

sub handle_result {
    my ($file, $status, $ret) = @_;
    print "[ $file ] " if !$o->synchronous;

    # bad status
    if ($status eq 'error') {
        print "ERROR\n";
        push @errors, [ $file, 'Process exited prematurely' ];
    }

    # skipped.
    elsif ($ret->{skipped}) {
        print "SKIP\n";
    }

    # error.
    elsif ($ret->{error}) {
        print $o->clean ? "CLEAN\n" : "ERROR\n";
        push @errors, [ $file, $ret->{error}, $o->clean ];
    }

    # good status
    else {
        print "OK\n";
    }

    # show stuff
    if ($status ne 'error') {
        print "=== Tokenization ===\n$$ret{tokenization}\n"
            if length $ret->{tokenization};
        print "=== Document Model ===\n$$ret{construction}\n"
            if length $ret->{construction};
    }

    finish() if !--$pending;
}

sub finish {
    $loop->stop if $loop;

    # show errors
    foreach my $error (@errors) {
        my ($file, $msg) = @$error;
        print "\n\n[ $file ]\n\n$msg\n";
    }

    my $e = scalar(grep !$_->[2], @errors) || 'no';
    my $s = $e ne '1' ? 's' : '';
    print "\nCompilation completed with $e error$s.\n";
}

# returns {
#   file            => the input file path,
#   build           => the build directory,
#   pm              => the path to the .frt.pm file,
#   tokenization    => string of tokenization if -tv enabled,
#   construction    => model of dom if -dv enabled,
#   skipped         => true if the file was skipped
# }
sub do_file {
    my $file = shift;
    print "[ $file ] " if $o->synchronous;

    # check if it's been changed
    my ($name, $path) = fileparse($file);
    my $build = "$path/build";
    my $docs  = "$path/doc";
    my $pm    = "$build/$name.pm";
    my $md    = "$docs/$name.md";

    my $ret = {
        file  => $file,
        build => $build,
        pm    => $pm
    };

    # we might be able to skip this
    if (!$o->noskip) {
        my @stat1 = stat $pm;
        my @stat2 = stat $file;
        if (@stat1 && $stat1[9] > $stat2[9]) {
            $ret->{skipped} = 1;
            return $ret;
        }
    }

    # clean.
    if ($o->clean) {
        return error($ret, undef, undef, $pm, $md, 'Clean');
    }

    # open the output files.
    my ($fh, $dfh);
    # if ($o->stdout) { $fh = \*STDOUT }

    mkdir $build or die "Couldn't create $build" if !-d $build;
    open $fh, '>', $pm or die "Couldn't open $pm to write";

    if ($o->gendocs) {
        require Ferret::Markdown;
        mkdir $docs or die "Couldn't create $docs" if !-d $docs;
        open $dfh, '>', $md or die "Couldn't open $md to write";
        $ret->{md} = $md;
    }

    # parse the input file.
    my $str = eval { slurp($file) } or return error($ret, $fh, $dfh, $pm, $md, $!);

    # tokenize.
    my ($err, @tok) = Ferret::Lexer::Tokenizer::tokenize("$str\n", $file);
    if ($o->tokens && !$err) {
        my $tok = F::show_tok(@tok);
        print $fh "# === Tokenization ===\n";
        print $fh commentize($tok), "\n";
        $ret->{tokenization} = $tok if $o->verbose;
    }
    return error($ret, $fh, $dfh, $pm, $md, $$err) if $err;

    # construct elements.
    my $doc = F::new('Document', name => $file);
       $err = Ferret::Lexer::Constructor::construct($doc, @tok);
    if ($o->dom || $err) {
        my $dom = F::show_dom($doc, $o->show_all);
        print $fh "# === Document Model ===\n"  unless $err;
        print $fh commentize($dom), "\n"        unless $err;
        $ret->{construction} = $dom if $o->verbose || $err;
    }
    return error($ret, $fh, $dfh, $pm, $md, $$err) if $err;

    # compile to Perl.
    my $compiled = Ferret::Perl::main($doc);
    beautify(\$compiled) if $o->beautify;
    minify(\$compiled)   if $o->minify;

    # write to .pm
    print $fh $compiled;
    close $fh;

    # generate documentation.
    if ($o->gendocs) {
        my $markdown = Ferret::Markdown::main($doc);

        # write to .md
        print $dfh $markdown;
        close $dfh;

    }


    return $ret;
}

sub perltidy {
    my ($ref, %opts) = @_;
    require Perl::Tidy;
    Perl::Tidy::perltidy(
        source      => $ref,
        destination => $ref,
        argv        => '',
        %opts
    );
}

sub beautify {
    my $ref = shift;
    perltidy($ref);
}

sub minify {
    my $ref = shift;
    perltidy($ref, argv => '--mangle -dac');
    $$ref =~ s/\n//g;
}

sub commentize {
    my @lines = split /\n/, join '', @_;
    return join("\n", map("# $_", @lines));
}

sub error {
    my ($ret, $fh, $fh2, $pm, $md, $msg) = @_;
    close $fh   if $fh;
    close $fh2  if $fh2;
    unlink $pm  if $pm;
    unlink $md  if $md;
    $ret->{error} = $msg;
    return $ret;
}
