#!/usr/bin/perl
# Copyright (c) 2015, Mitchell Cooper

use warnings;
use strict;
use 5.010;

use utf8;
use open ':std', ':encoding(UTF-8)';

use Cwd             'abs_path';
use File::Slurp     'slurp';
use File::Find      'find';
use Scalar::Util    'blessed';
use File::Basename  'fileparse';
use IO::Async::Function;
use IO::Async::Loop;
use Getopt::Long::Descriptive;
use JSON::XS;

BEGIN {
    use FindBin;
    use lib 'lib';
    our $bin = $FindBin::Bin;
    use lib "$FindBin::Bin/lib";
    do '/etc/ferret.conf' or die "config error: ".($@ || $!)
}

use Ferret::Lexer;

my ($o, $usage) = describe_options(
    "$0 %o [file ...]",
    [ 'noskip|n'        => 'do not skip unchanged files'                ],
    [ 'synchronous|y'   => 'work one file at a time in a single thread '],
    [ 'clean|c'  => 'clean up build directories', {implies => 'noskip'} ],
    [ 'tokens|t'        => 'write tokenization'                         ],
    [ 'dom|d'           => 'write lexer object tree (DOM)'              ],
    [ 'show-all'        => 'include unknown objects in DOM'             ],
    [ 'verbose|v'       => 'print tokens/DOM to STDOUT (with -d/t)'     ],
    #[ 'stdout|s'        => 'write to STDOUT instead of file'            ],
    [ 'beautify|p'      => 'beautify code with perltidy'                ],
    [ 'minify|m'        => 'minify code'                                ],
    [ 'help|h'          => 'show help'                                  ]
);

# show help.
print($usage->text) and exit if $o->help;

my (
    $loop,      # IO::Async::Loop
    $function,  # IO::Async compile function
    $pending,   # number of files in progress
    @errors,    # postponed errors
    %done       # files already done
);

# find the files.
my @files = grep m/\.(frt|frtdoc)$/, @ARGV;
if (!@files) {
    find({ wanted => sub {
        my $f = $File::Find::name;
        if ($f =~ m/\.(frt|frtdoc)$/ ) {
            push @files, $f;
        }
    }, no_chdir => 1 }, '.');
}

# do it synchronously.
if ($o->synchronous) {
    $pending = scalar @files;
    handle_result($_, 'return', do_file($_)) foreach @files;
}

# or asynchronously.
else {
    $loop = IO::Async::Loop->new;
    $function = IO::Async::Function->new(code => \&do_file);
    $loop->add($function);
    async_do_file($_) foreach @files;
    $loop->run;
}

sub async_do_file {
    my $file = shift;
    $pending++;
    $function->call(
        args => [ $file ],
        on_result => sub { handle_result($file, @_) }
    );
}

sub handle_result {
    my ($file, $status, $ret) = @_;
    print "[ $file ] " if !$o->synchronous;

    # bad status
    if ($status eq 'error') {
        print "ERROR\n";
        push @errors, [ $file, 'Process exited prematurely' ];
    }

    # skipped.
    elsif ($ret->{skipped}) {
        print "SKIP\n";
    }

    # error.
    elsif ($ret->{error}) {
        print $o->clean ? "CLEAN\n" : "ERROR\n";
        push @errors, [ $file, $ret->{error}, $o->clean ];
    }

    # good status
    else {
        print "OK\n";
    }

    # show stuff
    if ($status ne 'error') {
        print "=== Tokenization ===\n$$ret{tokenization}\n"
            if length $ret->{tokenization};
        print "=== Document Model ===\n$$ret{construction}\n"
            if length $ret->{construction};
    }

    finish() if !--$pending;
}

sub finish {
    $loop->stop if $loop;

    # show errors
    foreach my $error (@errors) {
        my ($file, $msg) = @$error;
        print "\n\n[ $file ]\n\n$msg\n";
    }

    my $e = scalar(grep !$_->[2], @errors) || 'no';
    my $s = $e ne '1' ? 's' : '';
    print "\nCompilation completed with $e error$s.\n";
}

# returns {
#   file            => the input file path,
#   build           => the build directory,
#   pm              => the path to the .frt.pm file,
#   tokenization    => string of tokenization if -tv enabled,
#   construction    => model of dom if -dv enabled,
#   skipped         => true if the file was skipped
# }
sub do_file {
    my $file = shift;
    print "[ $file ] " if $o->synchronous;

    # split file into parts.
    my ($write_dir, $write_file);
    my ($name, $path, $ext) = fileparse($file, qr/\.[^.]*/);
    my $abs     = abs_path($file);
    my $is_docs = $ext eq '.frtdoc';
    my $ret     = { file => $file, abs => $abs };

    # writing to .md.
    if ($is_docs) {
        my $docs        = "$path/doc";
        $write_dir      = $docs;
        $write_file     = "$docs/$name.md";
        $ret->{docs}    = $docs;
        $ret->{md}      = $write_file;
    }

    # writing to .pm.
    else {
        my $build       = "$path/build";
        $write_dir      = $build;
        $write_file     = "$build/$name$ext.pm";
        $ret->{build}   = $build;
        $ret->{pm}      = $write_file;
    }

    # we might be able to skip this
    if (!$o->noskip) {
        my @stat1 = stat $write_file;
        my @stat2 = stat $file;
        if (@stat1 && $stat1[9] > $stat2[9]) {
            $ret->{skipped} = 1;
            return $ret;
        }
    }

    # clean.
    if ($o->clean) {
        return error($ret, $write_file, 'Clean');
    }

    # open the output file.
    my $fh; # if ($o->stdout) { $fh = \*STDOUT }
    mkdir $write_dir or die "Couldn't create $write_dir" if !-d $write_dir;
    open $fh, '>', $write_file or die "Couldn't open $write_file to write";

    # see if we've already constructed it.
    my $doc = $done{$abs};
    if (!$doc) {

        # parse the input file.
        my $str = eval { slurp($file) } or return error($ret, $fh, $write_file, $!);

        # tokenize.
        my ($err, @tok) = Ferret::Lexer::Tokenizer::tokenize("$str\n", $file);
        if ($o->tokens && !$err && !$is_docs) {
            my $tok = F::show_tok(@tok);
            print $fh "# === Tokenization ===\n";
            print $fh commentize($tok), "\n";
            $ret->{tokenization} = $tok if $o->verbose;
        }
        return error($ret, $fh, $write_file, $$err) if $err;

        # construct elements.
        $doc = F::new('Document', name => $file);
        $err = Ferret::Lexer::Constructor::construct($doc, @tok);
        if ($o->dom || $err) {
            my $dom = F::show_dom($doc, $o->show_all);
            print $fh "# === Document Model ===\n"  if !$err && !$is_docs;
            print $fh commentize($dom), "\n"        if !$err && !$is_docs;
            $ret->{construction} = $dom if $o->verbose || $err;
        }

        return error($ret, $fh, $write_file, $$err) if $err;
        $done{$abs} = $doc;
    }

    # compile to Markdown.
    if ($is_docs) {
        require Ferret::Markdown;

        $doc->{name} = $abs;
        my $markdown = Ferret::Markdown::main($doc);

        print $fh $markdown;
        close $fh;
    }

    # compile to Perl.
    else {
        require Ferret::Perl;

        my $compiled = Ferret::Perl::main($doc);
        beautify(\$compiled) if $o->beautify;
        minify(\$compiled)   if $o->minify;

        print $fh $compiled;
        close $fh;
    }

    return $ret;
}

sub perltidy {
    my ($ref, %opts) = @_;
    require Perl::Tidy;
    Perl::Tidy::perltidy(
        source      => $ref,
        destination => $ref,
        argv        => '',
        %opts
    );
}

sub beautify {
    my $ref = shift;
    perltidy($ref);
}

sub minify {
    my $ref = shift;
    perltidy($ref, argv => '--mangle -dac');
    $$ref =~ s/\n//g;
}

sub commentize {
    my @lines = split /\n/, join '', @_;
    return join("\n", map("# $_", @lines));
}

sub error {
    my ($ret, $fh, $output_file, $msg) = @_;
    close $fh if $fh;
    unlink $output_file if $output_file;
    $ret->{error} = $msg;
    return $ret;
}
