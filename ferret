#!/usr/bin/perl
# Copyright (c) 2014 Mitchell Cooper

use warnings;
use strict;
use 5.010;

use utf8;
use open ':std', ':encoding(UTF-8)';

use File::Slurp  'slurp';
use Scalar::Util 'blessed';
use Getopt::Long::Descriptive;
use JSON::XS;


BEGIN {
    use FindBin;
    use lib 'lib';
    our $bin = $FindBin::Bin;
    use lib "$FindBin::Bin/lib";
}

BEGIN {
    my $libs = $Ferret::ferret_libs = do '/etc/ferret.conf';
    ref $libs eq 'ARRAY' or die "config error";
    $Ferret::ferret_root = shift @$libs;
    unshift @INC, @$libs;
}

use Ferret::Lexer;
use Ferret::Perl;

sub inter  (@);
sub interf (@);

my ($o, $usage) = describe_options(
    "$0 %o [file ...]",
    [ 'no-skip|n'       => 'do not skip unchanged files'                ],
    [ 'tokens|t'        => 'show tokenization'                          ],
    [ 'dom|d'           => 'show lexer object tree (DOM)'               ],
    [ 'show-all'        => 'include unknown objects in DOM'             ],
    [ 'stdout|s'        => 'write to STDOUT instead of file'            ],
    [ 'comments|c'      => 'write tokens/DOM as comments (with -t/-d)'  ],
    [ 'beautify|p'      => 'beautify code with perltidy'                ],
    [ 'minify|m'        => 'minify code'                                ],
    [ 'help|h'          => 'show help'                                  ]
);

# show help.
print($usage->text) and exit if $o->help;

# handle each file.
do_file($_) foreach grep { substr($_, -4) eq '.frt' } @ARGV;

my $fh;
sub do_file {
    my $file = shift;
    print "[ $file ]";

    # check if it's been changed
    if (!$o->no_skip) {
        my @stat1 = stat "$file.pm";
        my @stat2 = stat $file;
        if (@stat1 && $stat1[9] > $stat2[9]) {
            say " skipped";
            return;
        }
    }
    print "\n";

    # open the output file.
    if ($o->stdout) { $fh = \*STDOUT }
    else            { open $fh, '>', "$file.pm" }

    # parse the input file.
    my $str = eval { slurp($file) } or error($file, $!);

    # tokenize.
    my ($err, @tok) = Ferret::Lexer::Tokenizer::tokenize("$str\n");
    if ($o->tokens) {
        inter "=== Tokenization ===\n";
        inter Ferret::Lexer::show_tok(@tok);
    }
    error($file, $$err) if $err;

    # construct elements.
    my $doc = F::Document->new(name => $file);
       $err = Ferret::Lexer::Constructor::construct($doc, @tok);
    if ($o->dom) {
        inter "=== Document Model ===\n";
        inter Ferret::Lexer::show_dom($doc, $o->show_all);
    }
    error($file, $$err) if $err;

    # compile to Perl.
    my $compiled = Ferret::Perl::main($doc);
    beautify(\$compiled) if $o->beautify;
    minify(\$compiled)   if $o->minify;

    # write to file.
    print $fh $compiled;
    close $fh;

}

sub inter (@) {
    my @lines = split /\n/, join '', @_;
    say $fh join("\n", map("# $_", @lines));
    say     join("\n", @lines);
}

sub interf (@) {
    my $str = shift;
    $str = sprintf $str, @_;
    inter($str);
}

sub perltidy {
    my ($ref, %opts) = @_;
    require Perl::Tidy;
    Perl::Tidy::perltidy(
        source      => $ref,
        destination => $ref,
        argv        => '',
        %opts
    );
}

sub beautify {
    my $ref = shift;
    perltidy($ref);
}

sub minify {
    my $ref = shift;
    perltidy($ref, argv => '--mangle -dac');
    $$ref =~ s/\n//g;
}

sub error {
    my ($file, $msg) = @_;
    unlink "$file.pm";
    die "\n$msg\n";
}
